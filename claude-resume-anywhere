#!/bin/bash

# Default sort field
SORT_FIELD="timestamp"

# Parse command line options
while getopts "s:" opt; do
    case $opt in
        s)
            SORT_FIELD="$OPTARG"
            ;;
        \?)
            echo "Usage: $0 [-s sort_field]" >&2
            echo "  -s: Field to sort by (default: timestamp)" >&2
            exit 1
            ;;
    esac
done

# Function to extract cwd from first message in a jsonl file
get_cwd_from_jsonl() {
    local file="$1"
    # Get the first line and extract the cwd field
    head -n1 "$file" 2>/dev/null | jq -r '.cwd // empty' 2>/dev/null
}

# Function to extract a field from first message in a jsonl file
get_field_from_jsonl() {
    local file="$1"
    local field="$2"
    # Get the first line and extract the specified field
    head -n1 "$file" 2>/dev/null | jq -r ".$field // empty" 2>/dev/null
}

# Function to extract first user message from jsonl file
get_first_message() {
    local file="$1"
    # Get the first user message content, truncate to 80 chars
    local message=$(head -n1 "$file" 2>/dev/null | jq -r 'select(.type == "user") | .message.content // empty' 2>/dev/null | head -n1 | cut -c1-80)
    if [ -n "$message" ] && [ "$message" != "null" ]; then
        # Add ellipsis if truncated
        if [ ${#message} -eq 80 ]; then
            echo "${message}..."
        else
            echo "$message"
        fi
    else
        echo ""
    fi
}

# Find all jsonl files in the projects directory
project_dir="$HOME/.claude/projects"
if [ ! -d "$project_dir" ]; then
    echo "Error: Directory $project_dir not found" >&2
    exit 1
fi

# Collect all projects with their metadata
declare -a projects=()

while IFS= read -r -d '' file; do
    cwd=$(get_cwd_from_jsonl "$file")
    if [ -n "$cwd" ]; then
        sort_value=$(get_field_from_jsonl "$file" "$SORT_FIELD")
        message=$(get_first_message "$file")
        session_id=$(basename "$file" .jsonl)
        # Store as tab-separated: sort_value, cwd, message, session_id, file
        projects+=("${sort_value}	${cwd}	${message}	${session_id}	${file}")
    fi
done < <(find "$project_dir" -name "*.jsonl" -type f -print0)

# Check if we found any projects
if [ ${#projects[@]} -eq 0 ]; then
    echo "No Claude projects found in $project_dir" >&2
    exit 1
fi

# Sort projects by the sort field and create display items
declare -a display_items=()
declare -a sorted_projects=()
while IFS=$'\t' read -r sort_value cwd message session_id file; do
    if [ -n "$message" ]; then
        display_items+=("${cwd} | ${message}")
    else
        filename=$(basename "$file")
        display_items+=("${cwd} | Session: $filename")
    fi
    sorted_projects+=("${sort_value}	${cwd}	${message}	${session_id}	${file}")
done < <(printf '%s\n' "${projects[@]}" | sort -r)

# Use fzf to select a cwd
selected=$(printf '%s\n' "${display_items[@]}" | fzf --prompt="Select a project directory to resume (sorted by $SORT_FIELD): " --height=40% --reverse)

if [ -n "$selected" ]; then
    # Extract just the cwd part (before the pipe)
    selected_cwd=$(echo "$selected" | cut -d'|' -f1 | xargs)
    
    # Find the index of the selected item to get the session ID
    selected_index=-1
    for i in "${!display_items[@]}"; do
        if [ "${display_items[$i]}" = "$selected" ]; then
            selected_index=$i
            break
        fi
    done
    
    if [ $selected_index -eq -1 ]; then
        echo "Error: Could not find selected item" >&2
        exit 1
    fi
    
    # Extract session ID from the sorted projects array
    IFS=$'\t' read -r sort_value cwd message session_id file <<< "${sorted_projects[$selected_index]}"
    
    # Change to the selected directory
    if [ -d "$selected_cwd" ]; then
        echo "Resuming session $session_id in: $selected_cwd"
        cd "$selected_cwd" && exec claude --resume "$session_id"
    else
        echo "Error: Directory $selected_cwd no longer exists" >&2
        exit 1
    fi
fi